# SPDX-License-Identifier: GPL-3.0-or-later
#
# This file is part of the Waymarked Trails Map Project
# Copyright (C) 2024 Sarah Hoffmann
""" Main function for building a complex route geometry.
"""
from collections import defaultdict
from itertools import pairwise

from . import route_types as rt


def build_route(members: list[rt.BaseWay | rt.RouteSegment]) -> rt.RouteSegment:
    """ Create a Route representation for the given list of members.

        Members is a list of SimpleWays and Routes as generated by
        get_base_objects().
    """

    members = _ways_to_segments(members)

    if len(members) == 1:
        return rt.RouteSegment(length=members[0].length, main=[members[0]],
                               appendices=[])

    mains = []
    alternatives = []
    appendices = []
    for i, m in enumerate(members):
        match m.role:
            case '':
                mains.append(m)
            case 'alternative' | 'detour' | 'alternate' | 'alternate_route' | 'variant':
                alternatives.append((i, m))
            case _:
                appendices.append((i, m))

    _flip_order(mains)

    return rt.RouteSegment(length=sum(seg.length for seg in mains),
                           main=mains, appendices=[a[1] for a in appendices])



def _ways_to_segments(members: list[rt.BaseWay | rt.RouteSegment]
                      ) -> list[rt.WaySegment | rt.RouteSegment]:
    """ Combine any BaseWays in the list to WaySegments.
        Return the new list.
    """
    out = []

    for member in members:
        if not isinstance(member, rt.BaseWay):
            # Already a segment, leave untouched
            out.append(member)
        else:
            if not (out and isinstance(out[-1], rt.WaySegment) and out[-1].append_way(member)):
                out.append(rt.WaySegment(length=member.length, ways=[member]))

    return out


def _flip_order(segments: list[rt.WaySegment | rt.RouteSegment]) -> None:
    """ Recheck the order of single-element WaySegments. They might still
        need to be flipped according to their neighbours.
    """
    for s1, s2 in pairwise(segments):
        if s1.last != s2.first:
            if s1.is_reversable() and s1.first == s2.first:
                s1.reverse()
            elif s2.is_reversable() and s1.first == s2.last:
                s1.reverse()
                s2.reverse()
            elif s1.is_reversable() and s2.is_reversable() and s1.last == s2.last:
                s2.reverse()
