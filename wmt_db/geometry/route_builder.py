# SPDX-License-Identifier: GPL-3.0-or-later
#
# This file is part of the Waymarked Trails Map Project
# Copyright (C) 2024 Sarah Hoffmann
""" Main function for building a complex route geometry.
"""
from collections import defaultdict
from itertools import pairwise

import shapely

from . import route_types as rt


def build_route(members: list[rt.BaseWay | rt.RouteSegment]) -> rt.RouteSegment:
    """ Create a Route representation for the given list of members.

        Members is a list of SimpleWays and Routes as generated by
        get_base_objects().
    """

    members = _ways_to_segments(members)

    if len(members) == 1:
        return rt.RouteSegment(length=members[0].length, main=members, appendices=[])

    mains = []
    alternatives = []
    appendices = []
    for m in members:
        match m.role:
            case '':
                mains.append(m)
            case 'alternative' | 'detour' | 'alternate' | 'alternate_route' | 'variant':
                alternatives.append(m)
            case _:
                appendices.append(m)

    _join_oneways(mains)
    _flip_order(mains)

    route = rt.RouteSegment(length=sum(seg.length for seg in mains),
                            main=mains, appendices=appendices)
    route.adjust_start_point(0)

    return route


def _ways_to_segments(members: list[rt.BaseWay | rt.RouteSegment]
                      ) -> list[rt.WaySegment | rt.RouteSegment]:
    """ Combine any BaseWays in the list to WaySegments.
        Return the new list.
    """
    out = []

    for member in members:
        if not isinstance(member, rt.BaseWay):
            # Already a segment, leave untouched
            out.append(member)
        else:
            if not (out and isinstance(out[-1], rt.WaySegment) and out[-1].append_way(member)):
                out.append(rt.WaySegment(length=member.length, ways=[member]))

    return out


def _flip_order(segments: list[rt.WaySegment | rt.RouteSegment]) -> None:
    """ Recheck the order of single-element WaySegments. They might still
        need to be flipped according to their neighbours.
    """
    for i, (s1, s2) in enumerate(pairwise(segments)):
        if s1.last != s2.first:
            s1_flippable = s1.is_reversable() \
                           and (i <= 0 or s1.first != segments[i - 1].last)
            if s1_flippable and s1.first == s2.first:
                s1.reverse()
            elif s1_flippable and s2.is_reversable() and s1.first == s2.last:
                s1.reverse()
                s2.reverse()
            elif s2.is_reversable() and s1.last == s2.last:
                s2.reverse()


def _join_oneways(segments: list[rt.AnySegment]) -> None:
    """ Convert adjoining one-ways and roundabouts to
        alternative segments.
    """
    next_id = 0
    while (seg := _next_oneway(segments, next_id)) is not None:
        endidx = len(segments) if seg[1] < 0 else seg[1]
        new_segments = _process_oneways(segments, seg[0], endidx - 1)
        segments[seg[0]:endidx] = new_segments
        if seg[1] < 0:
            break
        next_id = seg[0] + len(new_segments)


def _next_oneway(segments: list[rt.AnySegment], start_at: int) -> None:
    """ Find the next continuous line of segments that are directional.

        A closed oneway is always returned on its own.
    """
    for i, seg in enumerate(segments[start_at:]):
        if seg.direction != 0:
            oneway_start = i + start_at
            break
    else:
        return None

    first = segments[oneway_start]
    if first.is_closed:
        return (oneway_start, oneway_start + 1)

    endpoints = set((first.first, first.last))
    for i, seg in enumerate(segments[oneway_start + 1:], oneway_start + 1):
        if seg.direction == 0 or seg.is_closed:
            return (oneway_start, i)
        for pt in (seg.first, seg.last):
            if pt in endpoints:
                endpoints.remove(pt)
            else:
                endpoints.add(pt)
        if not endpoints:
            return (oneway_start, i + 1)

    return (oneway_start, -1)


def _process_oneways(segments: list[rt.AnySegment], frm: int, to: int):
    """ Convert the given subset of segments into a split segment.

        frm is the first index belonging to the sublist, to the last
        index of the sublist.
    """
    # Compute the possible connection points.
    start_points = []
    if frm > 0:
        prevseg = segments[frm - 1]
        start_points.append(prevseg.last)
        if prevseg.is_reversable() and \
           (frm <= 1 or prevseg.first != segments[frm - 2].last):
           start_points.append(prevseg.first)

    end_points = []
    if to < len(segments) - 1:
        nextseg = segments[to + 1]
        end_points.append(nextseg.first)
        if nextseg.is_reversable() and \
         (to >= len(segments) - 2 or nextseg.last != segments[to + 2].first):
            end_points.append(nextseg.last)

    if frm == to:
        first = segments[frm]
        if isinstance(first, rt.WaySegment):
            if first.ways[0].is_closed:
                assert len(first.ways) == 1
                return [_make_roundabout(first.ways[0], start_points, end_points)]
            if first.is_closed:
                return [_make_circular(first, start_points, end_points)]
        # With only one segment, this can't possibly be a SplitSegment. Return.
        return [first]

    return _make_oneways_directional(segments[frm:to + 1], start_points, end_points)


def _make_roundabout(seg: rt.BaseWay, start_points, end_points) -> rt.SplitSegment:
    """ Build a split section from a single roundabout way.
    """
    if seg.direction == -1:
        seg.reverse()

    points = seg.geom.coords
    spt = None
    ept = None
    for i, pt in enumerate(points):
        if spt is None and pt in start_points:
            spt = i
        if ept is None and pt in end_points:
            ept = i

    if spt is None:
        spt = 0 if ept != 0 else int(len(points)/2)
    if ept is None:
        ept = int(len(points)/2)
        if ept == spt:
            ept = 0

    fwd_way = shapely.LineString(points[spt:ept + 1] if spt < ept else points[spt:] + points[1:ept + 1])
    bwd_way = shapely.LineString(points[ept:spt + 1] if ept < spt else points[ept:] + points[1:spt + 1])
    fwd = rt.BaseWay(osm_id=seg.osm_id, tags=seg.tags,
                     length=int(round(seg.length*fwd_way.length/seg.geom.length)),
                     direction=1, geom=fwd_way, role=seg.role)
    bwd = rt.BaseWay(osm_id=seg.osm_id, tags=seg.tags,
                     length=int(round(seg.length*bwd_way.length/seg.geom.length)),
                     direction=-1, geom=bwd_way.reverse(), role=seg.role)

    return rt.SplitSegment(length=fwd.length,
                           forward=[rt.WaySegment(length=fwd.length, ways=[fwd])],
                           backward=[rt.WaySegment(length=bwd.length, ways=[bwd])],
                           first=fwd.first,
                           last=fwd.last)


def _make_circular(seg: rt.WaySegment, start_points, end_points) -> rt.SplitSegment | rt.WaySegment:
    """ Convert a cicular multi-way WaySegment into a split segment by
        cutting at the most conventient place.
    """
    if seg.first in start_points and end_points:
        for i, way in enumerate(seg.ways):
            if i > 0 and way.first in end_points:
                split_idx = i
                break
        else:
            mp = shapely.MultiPoint(end_points)
            dist, split_idx = min((shapely.distance(mp, shapely.Point(way.first)), i)
                                  for i, way in enumerate(seg.ways) if i > 0)
    elif seg.first in end_points and start_points:
        for i, way in enumerate(seg.ways):
            if i > 0 and way.first in start_points:
                split_idx = i
                break
        else:
            mp = shapely.MultiPoint(start_points)
            dist, split_idx = min((shapely.distance(mp, shapely.Point(way.first)), i)
                                  for i, way in enumerate(seg.ways) if i > 0)
    else:
        split_idx = int(len(seg.ways)/2)

    fwd_ways = seg.ways[0:split_idx]
    fwd = rt.WaySegment(length=sum(s.length for s in fwd_ways), ways = fwd_ways)

    bwd_ways = seg.ways[split_idx:]
    bwd = rt.WaySegment(length=sum(s.length for s in bwd_ways), ways=bwd_ways)

    if seg.direction == 1:
        bwd.reverse()
    else:
        fwd.reverse()

    return rt.SplitSegment(length=fwd.length, forward=[fwd], backward=[bwd],
                           first=fwd.first, last=fwd.last)


def _make_oneways_directional(segments: list[rt.AnySegment], start_points, end_points):
    """ Build a split section from a list of segments arranged in direction
        of the route.

        This is the fallback implementation that also deals with holes in the
        route and badly ordered routes.
    """
    out_segments = []
    # determine starting point
    first_point = segments[0].first
    for seg in segments:
        if seg.first in start_points:
            first_point = seg.first
            break
        if seg.is_reversable() and seg.last in start_points:
            first_point = seg.last
            break
    else:
        # Nothing to determine the starting point,
        # look ahead from the first segment to get a hint on its direction.
        first_seg = None
        for seg in segments:
            if first_seg is None:
                first_seg is seg
                continue
            if first_seg.direction == -seg.direction:
                if first_seg.first == seg.first:
                    first_point = first_seg.first
                    break
                if seg.is_reversable() and first_seg.last == seg.last:
                    first_point = first_seg.last
                    break
            else:
                if first_seg.last == seg.first:
                    first_point = first_seg.last
                    break
                if seg.is_reversable() and first_seg.first == seg.last:
                    first_point = first_seg.first
                    break

    endpts = {1: first_point, -1: first_point}
    segs = {1: [], -1: []}  # indexed by direction

    for i, seg in enumerate(segments):
        if endpts[seg.direction] in end_points:
            if seg.is_reversable():
                seg.reverse()
        elif seg.first != endpts[seg.direction] and seg.is_reversable()\
           and not seg.last in end_points:
            if seg.last == endpts[-seg.direction] or seg.first in end_points:
                seg.reverse()
            else:
                # Look ahead if the next segment might give a hint on the direction.
                for ns in segments[i + 1:]:
                    if seg.direction == ns.direction:
                        if seg.last == ns.first:
                            break
                        if ns.is_reversable() and seg.first == ns.last:
                            seg.reverse()
                            break
                    else:
                        if seg.first == ns.first:
                            seg.reverse()
                            break
                        if ns.is_reversable() and seg.last == ns.last:
                            break

        segs[seg.direction].append(seg)
        endpts[seg.direction] = seg.last

        if endpts[1] == endpts[-1] and segs[1] and segs[-1]:
            out_segments.append(rt.SplitSegment(
                length=sum(s.length for s in segs[1]),
                forward=segs[1],
                backward=segs[-1],
                first=first_point, last=endpts[1]))

            segs = {1: [], -1: []}
            first_point = endpts[1]

    if segs[1]:
        if segs[-1]:
            out_segments.append(rt.SplitSegment(
                length=sum(s.length for s in segs[1]),
                forward=segs[1],
                backward=segs[-1],
                first=first_point,
                last=endpts[-1] if endpts[-1] in end_points else endpts[1]))
        else:
            out_segments.extend(segs[1])
    elif segs[-1]:
        out_segments.extend(segs[-1])

    return out_segments
